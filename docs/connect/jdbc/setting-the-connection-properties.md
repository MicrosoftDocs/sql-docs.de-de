---
title: Festlegen von Verbindungseigenschaften
description: Die Eigenschaften der Verbindungszeichenfolge für den Microsoft JDBC-Treiber für SQL Server kann auf verschiedene Arten angegeben werden.
ms.custom: ''
ms.date: 12/04/2020
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
ms.assetid: f1b62700-f046-488d-bd6b-a5cd8fc345b7
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 29d8ab48623b2eeb2d4cd3a367499bdbe67375f7
ms.sourcegitcommit: cad737d30e5a80033f3b021cc3f0d47c00756a6b
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/04/2020
ms.locfileid: "96614472"
---
# <a name="setting-the-connection-properties"></a>Festlegen von Verbindungseigenschaften

[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

Es gibt verschiedene Möglichkeiten, um die Eigenschaften für die Verbindungszeichenfolge anzugeben:

- Als Name=Wert-Eigenschaften in der Verbindungs-URL, wenn Verbindungen mit der DriverManager-Klasse hergestellt werden.
- Als Name=Wert-Eigenschaften im *Properties*-Parameter der Connect-Methode in der DriverManager-Klasse.
- Als Werte in der entsprechenden Festlegungsmethode der Datenquelle des Treibers. Beispiel:  
  
    ```java
    datasource.setServerName(value)  
    datasource.setDatabaseName(value)  
    ```  
  
## <a name="remarks"></a>Bemerkungen

Bei den Namen von Eigenschaften wird Groß-/Kleinschreibung unterschieden. Doppelte Eigenschaftennamen werden in der folgenden Reihenfolge aufgelöst:  
  
1. API-Argumente (wie Benutzer und Kennwort)
2. Property-Auflistung.  
3. Letzte Instanz in der Verbindungszeichenfolge.
  
Darüber hinaus sind für Eigenschaftennamen unbekannte Werte zulässig. Die Groß-/Kleinschreibung der Werte wird vom JDBC-Treiber nicht überprüft.

Synonyme sind zulässig und werden in der gleichen Reihenfolge wie doppelte Eigenschaftennamen aufgelöst.

Die folgende Tabelle enthält eine Liste aller zurzeit verfügbaren Verbindungszeichenfolgeeigenschaften für den JDBC-Treiber.

| Eigenschaft<br/>type<br/>Standard | BESCHREIBUNG |
| :------------------------------ | :---------- |
| accessToken<br/><br/>String<br/><br/>NULL | Verwenden Sie diese Eigenschaft, um mithilfe eines Zugriffstokens eine Verbindung mit einer SQL-Datenbank herzustellen. **accessToken** können nicht unter Verwendung der Verbindungs-URL festgelegt werden. |
| applicationIntent<br/><br/>String<br/><br/>ReadWrite | Deklariert den Arbeitsauslastungstyp der Anwendung beim Herstellen einer Verbindung mit einem Server. <br/><br/>Mögliche Werte sind **ReadOnly** und **ReadWrite**. <br/><br/>Weitere Informationen finden Sie unter [JDBC-Treiber-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](jdbc-driver-support-for-high-availability-disaster-recovery.md). |
| applicationName<br/><br/>String<br/>[&lt;=128 char]<br/><br/>NULL | Der Anwendungsname, oder „[!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]“, wenn kein Name angegeben ist.<br/><br/>Anhand dieser Eigenschaft wird die jeweilige Anwendung in den verschiedenen [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Profilerstellungs- und Protokollierungstools identifiziert. |
| authentication<br/><br/>String<br/><br/>NotSpecified | Ab Version 6.0 des Microsoft-JDBC-Treibers für SQL Server gibt diese optionale Eigenschaft an, welche SQL-Authentifizierungsmethode für die Verbindung verwendet werden soll. Mögliche Werte sind **ActiveDirectoryIntegrated**, **ActiveDirectoryPassword**, **ActiveDirectoryMSI**, **SqlPassword** und der Standardwert **NotSpecified**.<br/><br/> Verwenden Sie **ActiveDirectoryIntegrated**, um mithilfe der integrierten Windows-Authentifizierung eine Verbindung mit einer SQL-Datenbank herzustellen.<br/><br/> Verwenden Sie **ActiveDirectoryPassword**, um mithilfe eines Azure AD-Prinzipalnamens und des zugehörigen Kennworts eine Verbindung mit einer SQL-Datenbank herzustellen.<br/><br/> Verwenden Sie **ActiveDirectoryMSI**, um von einer Azure-Ressource aus eine Verbindung mit einer SQL-Datenbank herzustellen. Dabei kann es sich um einen virtuellen Azure-Computer, einen App Service oder eine Funktions-App handeln, die die Authentifizierung mithilfe einer verwalteten Identität (MSI) nutzen. <br><br>Folgende beiden Arten von verwalteten Identitäten werden bei Verwendung des Authentifizierungsmodus **ActiveDirectoryMSI** vom Treiber unterstützt: <br> 1. _Systemseitig zugewiesene verwaltete Identität_: Wird verwendet, um standardmäßig ein **accessToken** abzurufen. <br> 2. _Benutzerseitig zugewiesene verwaltete Identität_: Dient zum Abrufen von **accessToken**, wenn die Client-ID einer verwalteten Identität (MSI) mit der Verbindungseigenschaft **msiClientId** angegeben wird.<br/><br/> Verwenden Sie **SqlPassword**, um unter Verwendung der Eigenschaften **userName**/**user** und **password** eine Verbindung mit einer SQL Server-Instanz herzustellen.<br/><br/> Verwenden Sie **NotSpecified**, wenn keine dieser Authentifizierungsmethoden erforderlich ist.<br/><br/> **Wichtig:**  Wenn für die Authentifizierung ActiveDirectoryIntegrated festgelegt ist, müssen die beiden folgenden Bibliotheken installiert werden: **mssql-jdbc_auth-\<version>-\<arch>.dll** (verfügbar im Paket des JDBC-Treibers) und die Azure Active Directory-Authentifizierungsbibliothek für SQL Server (**ADAL.DLL**). ADAL kann installiert werden, indem [Microsoft ODBC Driver for SQL Server](../odbc/download-odbc-driver-for-sql-server.md) oder der [Microsoft OLE DB-Treiber für SQL Server](../oledb/download-oledb-driver-for-sql-server.md) installiert wird. Der JDBC-Treiber unterstützt nur Version **1.0.2028.318 und höher** für ADAL.DLL.<br/><br/> **Hinweis:**  Wird die Eigenschaft „Authentifizierung“ auf einen anderen Wert als **NotSpecified** festgelegt, verwendet der Treiber standardmäßig die TLS-Verschlüsselung (Transport Layer Security), die früher als SSL-Verschlüsselung (Secure Sockets Layer) bezeichnet wurde.<br/><br/> Informationen zum Konfigurieren der Azure Active Directory-Authentifizierung finden Sie unter [Herstellen einer Verbindung mit SQL-Datenbank unter Verwendung der Azure Active Directory-Authentifizierung](/azure/azure-sql/database/authentication-aad-overview). |
| authenticationScheme<br/><br/>String<br/><br/>NativeAuthentication | Gibt die Art der integrierten Sicherheit an, die für Ihre Anwendung verwendet werden soll. Mögliche Werte sind **JavaKerberos**, **NTLM** und der Standardwert **NativeAuthentication**.<br/><br/> **NativeAuthentication** bewirkt, dass der Treiber unter Windows `mssql-jdbc_auth-<version>-<arch>.dll` (z. B. `mssql-jdbc_auth-8.2.2.x64.dll`) lädt, was zum Abrufen integrierter Authentifizierungsinformationen verwendet wird. <br/><br/>  (Bei Verwendung der Treiberversionen 6.0 bis 7.4 heißt die geladene native Authentifizierungsbibliothek `sqljdbc_auth.dll`.) <br/><br/> Bei Verwendung von **authenticationScheme=JavaKerberos** müssen Sie den vollqualifizierten Domänennamen (Fully Qualified Domain Name, FQDN) in der Eigenschaft **serverName** oder **serverSpn** angeben. Andernfalls tritt ein Fehler auf (Server in Kerberos-Datenbank nicht gefunden).<br/><br/> Weitere Informationen zum Verwenden von **authenticationScheme=JavaKerberos** finden Sie unter [Herstellen von Verbindungen mit SQL Server mit der integrierten Kerberos-Authentifizierung](using-kerberos-integrated-authentication-to-connect-to-sql-server.md). <br/><br/> Bei Verwendung von **authenticationScheme=NTLM** müssen Sie in der Eigenschaft **domain** oder **domainName** die Windows-Domäne angeben, bei der die Authentifizierung über NTLM erfolgen soll. Sie müssen auch die Windows-Anmeldeinformationen in den Eigenschaften **user** bzw. **userName** und **password** angeben. Andernfalls tritt ein Fehler auf (Verbindungseigenschaften müssen angegeben werden).  |
| cancelQueryTimeout<br/><br/>INT<br/><br/>-1 | Ab Version 6.4 des Microsoft-JDBC-Treibers für SQL Server kann diese Eigenschaft zum Abbrechen des für die Verbindung festgelegten **queryTimeout** verwendet werden. Die Abfrageausführung reagiert nicht und löst keine Ausnahme aus, wenn eine TCP-Verbindung mit SQL Server im Hintergrund unterbrochen wird. Diese Eigenschaft ist nur anwendbar, wenn „queryTimeout“ auch für die Verbindung festgelegt ist. <br/><br/>Der Treiber wartet die Anzahl von Sekunden, die mit **cancelQueryTimeout** + **queryTimeout** angegeben ist, unterbricht dann die Verbindung und schließt den Kanal. <br/><br/>Der Standardwert für diese Eigenschaft ist „-1“, und das Standardverhalten ist es, unbegrenzt zu warten. |
| clientCertificate<br/><br/>String<br/><br/>NULL | Gibt den Speicherort des Zertifikats an, das für die Clientzertifikatauthentifizierung verwendet werden soll. Der JDBC-Treiber unterstützt die Dateierweiterungen PFX, PEM, DER und CER. <br/><br/>Ausführliche Informationen finden Sie unter [Clientzertifikatauthentifizierung für Loopbackszenarios](client-certification-authentication-for-loopback-scenarios.md). |
| clientKey <br/><br/>String<br/><br/>NULL | Gibt den Speicherort des privaten Schlüssels für PEM-, DER- und CER-Zertifikate an, die durch das clientCertificate-Attribut angegeben werden. <br/><br/>Ausführliche Informationen finden Sie unter [Clientzertifikatauthentifizierung für Loopbackszenarios](client-certification-authentication-for-loopback-scenarios.md). |
| clientKeyPassword <br/><br/>String<br/><br/>NULL | Diese Eigenschaft gibt die optionale Kennwortzeichenfolge für den Zugriff auf den privaten Schlüssel der clientKey-Datei an. <br/><br/>Ausführliche Informationen finden Sie unter [Clientzertifikatauthentifizierung für Loopbackszenarios](client-certification-authentication-for-loopback-scenarios.md). |
| columnEncryptionSetting<br/><br/>String<br/>["Enabled" &#124; "Disabled"]<br/><br/>Disabled | Legen Sie die Eigenschaft auf „Aktiviert“ fest, um das Feature Always Encrypted (AE) zu verwenden, beginnend mit dem Microsoft JDBC-Treiber 6.0 für SQL Server. Wenn AE aktiviert ist, werden vertrauliche Daten, die in verschlüsselten Datenbank-Spalten in SQL Server gespeichert sind, vom JDBC-Treiber transparent verschlüsselt und entschlüsselt.<br/><br/> Weitere Informationen zu **columnEncryptionSetting** finden Sie unter [Verwenden von Always Encrypted mit dem JDBC-Treiber](using-always-encrypted-with-the-jdbc-driver.md).<br/><br/> **Hinweis:**  Always Encrypted ist mit SQL Server 2016 oder höheren Versionen verfügbar. |
| databaseName,<br/>database<br/><br/>String<br/>[&lt;=128 char]<br/><br/>NULL | Der Name der Datenbank, zu der eine Verbindung hergestellt werden soll. <br/><br/>Ohne Angabe wird eine Verbindung zur Standarddatenbank erstellt. |
| delayLoadingLobs<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | Flag, das angibt, ob alle LOB-Objekte, die aus dem ResultSet abgerufen werden, gestreamt werden sollen oder nicht. Wenn diese Eigenschaft auf „false“ festgelegt wird, wird das gesamte LOB-Objekt ohne Streaming in den Arbeitsspeicher geladen. |
| domainName,<br/>Domäne<br/><br/>String<br/>NULL | Die Windows-Domäne, bei der die Authentifizierung mit NTLM erfolgen soll. |
| disableStatementPooling<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | Ein Flag, das angibt, ob das Anweisungspooling verwendet werden soll. |
| enablePrepareOnFirst...<br/>PreparedStatementCall<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | _enablePrepareOnFirstPreparedStatementCall_<br/><br/> Bei Festlegung auf „true“ kann das Handle für die vorbereitete Anweisung durch Aufrufen von <code>sp_prepexec</code> in der ersten Ausführung der vorbereiteten Anweisung erstellt werden. <br/><br/>Bei Festlegung auf „FALSE“ wird die erste Ausführung einer vorbereiteten Anweisung so geändert, dass <code>sp_executesql</code> aufgerufen und keine Anweisung vorbereitet wird. Bei der zweiten Ausführung wird <code>sp_prepexec</code> aufgerufen, um ein Handle für die vorbereitete Anweisung einzurichten. |
| enclaveAttestationUrl<br/><br/>String<br/><br/>NULL | Ab Microsoft JDBC-Treiber 8.2 für SQL Server weist diese optionale Eigenschaft die URL für den Nachweisdienstendpunkt an, Always Encrypted mit Secure Enclaves zu verwenden.<br/><br/>Weitere Informationen finden Sie unter [Always Encrypted mit Secure Enclaves](../../connect/jdbc/using-always-encrypted-with-secure-enclaves-with-the-jdbc-driver.md). |
| enclaveAttestationProtocol<br/><br/>String<br/><br/>NULL | Ab Microsoft JDBC-Treiber 8.2 für SQL Server weist diese optionale Eigenschaft das Nachweisprotokoll an, Always Encrypted mit Secure Enclaves zu verwenden. Aktuell ist **HGS** der einzige Wert, der für dieses Feld unterstützt wird.<br/><br/>Weitere Informationen finden Sie unter [Always Encrypted mit Secure Enclaves](../../connect/jdbc/using-always-encrypted-with-secure-enclaves-with-the-jdbc-driver.md). |
| encrypt<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | Bei Festlegung auf „TRUE“ verwendet [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] für alle zwischen Client und Server gesendeten Daten eine TLS-Verschlüsselung, sofern auf dem Server ein Zertifikat installiert ist. Der Standardwert ist FALSE.<br/><br/> Ab Version 6.0 des Microsoft JDBC-Treibers für SQL Server ist die neue Verbindungseinstellung „Authentifizierung“ verfügbar, die standardmäßig auf TLS-Verschlüsselung festgelegt ist. <br/><br/>Weitere Informationen finden Sie unter der Eigenschaft „Authentifizierung“. |
| failoverPartner<br/><br/>String<br/><br/>NULL | Der Name des Failoverservers, der in einer Datenbankspiegelungskonfiguration verwendet wird. Diese Eigenschaft wird bei einem Ausfall der Anfangsverbindung mit dem Prinzipalserver verwendet. Nachdem die Anfangsverbindung hergestellt wurde, wird diese Eigenschaft ignoriert. Diese Eigenschaft muss zusammen mit der databaseName-Eigenschaft verwendet werden.<br/><br/> **Hinweis:** Der Treiber unterstützt keine Angabe der Serverinstanz-Portnummer für die Failoverpartnerinstanz innerhalb der failoverPartner-Eigenschaft in der Verbindungszeichenfolge. Die Eigenschaften serverName, instanceName und portNumber der Prinzipalserverinstanz und die failoverPartner-Eigenschaft der Failoverpartnerinstanz können nicht in der gleichen Verbindungszeichenfolge angegeben werden.<br/><br/> Wenn Sie in der **Server**-Verbindungseigenschaft den Namen eines virtuellen Netzwerks angeben, kann die Datenbankspiegelung nicht verwendet werden. Weitere Informationen finden Sie unter [JDBC-Treiber-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md). |
| fips<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>„FALSE“ | In einer JVM-Umgebung mit aktiviertem FIPS sollte diese Eigenschaft **true** lauten. |
| fipsProvider<br/><br/>String<br/><br/>NULL | In JVM konfigurierter FIPS-Anbieter. Beispiele: BCFIPS oder SunPKCS11-NSS. In Version 6.4.0 entfernt. Ausführliche Informationen finden Sie [hier](https://github.com/Microsoft/mssql-jdbc/pull/460). |
| gsscredential<br/><br/>org.ietf.jgss.GSSCredential<br/><br/>NULL | Ab Version 6.2 des Microsoft-JDBC-Treibers für SQL Server können in dieser Eigenschaft Benutzeranmeldeinformationen übergeben werden, die für die eingeschränkte Kerberos-Delegierung verwendet werden sollen. <br/><br/>Hierbei sollte **integratedSecurity** auf **true** und **JavaKerberos** auf **authenticationScheme** festgelegt sein. |
| hostNameInCertificate<br/><br/>String<br/><br/>NULL | Der Hostname, der beim Überprüfen des TLS-/SSL-Zertifikats von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] verwendet werden soll.<br/><br/> Wenn die hostNameInCertificate-Eigenschaft nicht angegeben oder auf „NULL“ festgelegt ist, verwendet [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] den Eigenschaftswert **serverName** der Verbindungs-URL als Hostnamen zur Überprüfung des TLS-/SSL-Zertifikats von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].<br/><br/> **Hinweis:**  Diese Eigenschaft wird in Kombination mit den Eigenschaften **encrypt**/**authentication** und der Eigenschaft **trustServerCertificate** verwendet. Diese Eigenschaft hat nur dann Auswirkungen auf die Zertifikatüberprüfung, wenn die Verbindung die TLS-Verschlüsselung verwendet und die Eigenschaft **trustServerCertificate** auf „FALSE“ festgelegt ist. Vergewissern Sie sich, dass der an **hostNameInCertificate** übergebene Wert für eine erfolgreiche TLS-Verbindung dem allgemeinen Namen (CN, Common Name) oder dem DNS-Namen im alternativen Antragstellernamen (SAN, Subject Alternate Name) im Serverzertifikat entspricht. Weitere Informationen finden Sie unter [Verstehen der Verschlüsselungsunterstützung](../../connect/jdbc/understanding-ssl-support.md). |
| INSTANCENAME<br/><br/>String<br/>[&lt;=128 char]<br/><br/>NULL | Der Name der [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Instanz, mit der eine Verbindung hergestellt werden soll. Ohne Angabe wird eine Verbindung mit der Standardinstanz erstellt. Wenn "instanceName" und "port" angegeben werden, finden Sie nützliche Informationen in den Hinweisen für "port".<br/><br/> Wenn Sie in der **Server**-Verbindungseigenschaft den Namen eines virtuellen Netzwerks angeben, kann die **instanceName**-Verbindungseigenschaft nicht verwendet werden. Weitere Informationen finden Sie unter [JDBC-Treiberunterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md). |
| integratedSecurity<br/><br/>boolean<br/>["true"&#124;"false"]<br/><br/>false | Wird auf „true“ festgelegt, um anzugeben, dass [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] in Windows-Betriebssystemen Windows-Anmeldeinformationen verwendet. Bei Festlegung auf „true“ sucht der JDBC-Treiber im Cache für Anmeldeinformationen des lokalen Computers nach Anmeldeinformationen, die bei der Anmeldung eines Benutzers beim Computer oder Netzwerk angegeben wurden.<br/><br/> Wird auf „true“ festgelegt (mit **authenticationscheme=JavaKerberos**), um anzugeben, dass [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Kerberos-Anmeldeinformationen verwendet. Weitere Informationen zur Kerberos-Authentifizierung finden Sie unter [Herstellen von Verbindungen mit SQL Server mit der integrierten Kerberos-Authentifizierung](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). <br/><br/> Wird auf „true“ festgelegt (mit **authenticationscheme=NTLM**), um anzugeben, dass [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] NTLM-Anmeldeinformationen verwendet. <br/><br/> Falls „false“ müssen der Benutzername und das Kennwort angegeben werden. |
| jaasConfigurationName<br/><br/>String<br/><br/>SQLJDBCDriver | Ab Version 6.2 des Microsoft-JDBC-Treibers für SQL Server kann jede Verbindung mit SQL Server über eine eigene JAAS-Anmeldekonfigurationsdatei verfügen, um eine Kerberos-Verbindung herzustellen. Der Name der Anmeldekonfigurationsdatei kann über diese Eigenschaft übergeben werden. <br/> Standardmäßig legt der Treiber die Eigenschaft `useDefaultCcache = true` für IBM-JVMs und `useTicketCache = true` für andere JVMs fest. |
| keyStoreAuthentication<br/><br/>String<br/><br/>NULL | Ab Version 6.0 des Microsoft-JDBC-Treibers für SQL Server gibt diese Eigenschaft an, welcher Keystore für eine nahtlose Verbindung mit Always Encrypted verwendet werden soll, und legt einen Authentifizierungsmechanismus fest, der zur Authentifizierung beim Keystore verwendet werden soll. Version 6.0 des Microsoft-JDBC-Treibers für SQL Server unterstützt die nahtlose Einrichtung des Java-Keystore mithilfe dieser Eigenschaft, für die Sie **keyStoreAuthentication=JavaKeyStorePassword** festlegen müssen. Hinweis: Um diese Eigenschaft verwenden zu können, müssen Sie auch die Eigenschaften **keyStoreLocation** und **keyStoreSecret** für den Java-Keystore festlegen. <br/><br/>Weitere Informationen finden Sie unter [Verwenden von Always Encrypted mit dem JDBC-Treiber](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md). <br/><br/> Alternativ können Sie ab dem Microsoft JDBC-Treiber der Version 8.4 für **keyStoreAuthentication=KeyVaultManagedIdentity** oder **keyStoreAuthentication=KeyVaultClientSecret** die Azure Key Vault-Authentifizierung unter Verwendung verwalteter Identitäten festlegen. <br/><br/> Weitere Informationen zu diesem Thema finden Sie unter [Verwenden von Always Encrypted mit dem JDBC-Treiber](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md). |
| keyStoreLocation<br/><br/>String<br/><br/>NULL | Bei **keyStoreAuthentication=JavaKeyStorePassword** identifiziert die Eigenschaft **keyStoreLocation** den Pfad zu der Java-Keystoredatei, die den Spaltenhauptschlüssel speichert, der für Always Encrypted-Daten verwendet werden soll. Beachten Sie, dass der Pfad den Dateinamen des Keystores enthalten muss.<br/><br/>Weitere Informationen finden Sie unter [Verwenden von Always Encrypted mit dem JDBC-Treiber](using-always-encrypted-with-the-jdbc-driver.md). |
| keyStorePrincipalId<br/><br/>String<br/><br/>NULL | Wenn **keyStoreAuthentication=KeyVaultManagedIdentity** lautet, gibt die **keyStorePrincipalId**-Eigenschaft eine gültige Azure Active Directory-Anwendungsclient-ID an.  <br/><br/>Weitere Informationen zu diesem Thema finden Sie unter [Verwenden von Always Encrypted mit dem JDBC-Treiber](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md). |
| keyStoreSecret<br/><br/>String<br/><br/>NULL | Bei **keyStoreAuthentication=JavaKeyStorePassword** identifiziert die Eigenschaft **keyStoreSecret** das Kennwort, das sowohl für den Keystore als auch für den Schlüssel verwendet werden soll. Beachten Sie, dass zur Verwendung des Java-Keystores der Keystore und das Schlüsselkennwort übereinstimmen müssen.<br/><br/>Weitere Informationen finden Sie unter [Verwenden von Always Encrypted mit dem JDBC-Treiber](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md). |
| lastUpdateCount<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | Wenn der Wert dieser Eigenschaft auf "true" gesetzt ist, wird nur die letzte Updatezählung einer SQL-Anweisungen zurückgegeben, die an den Server übergeben wurde. Die Eigenschaft kann in einzelnen SELECT-, INSERT- oder DELETE-Anweisungen verwendet werden, wenn zusätzliche Updatezählungen von Servertriggern ignoriert werden sollen. Wenn diese Eigenschaft auf "false" gesetzt ist, werden alle Updatezählungen zurückgegeben, einschließlich der von Servertriggern.<br/><br/> **Hinweis:**  Diese Eigenschaft ist nur gültig, wenn sie mit den [executeUpdate](../../connect/jdbc/reference/executeupdate-method-sqlserverstatement.md)-Methoden verwendet wird. Alle anderen Ausführungsmethoden geben alle Ergebnisse und Updatezählungen zurück. Diese Eigenschaft betrifft nur Updatezählungen, die von Servertriggern zurückgegeben werden. Sie betrifft keine Resultsets oder Fehler, die Folge der Ausführung eines Triggers sind. |
| lockTimeout<br/><br/>INT<br/><br/>-1 | Die Wartezeit in Millisekunden, bevor die Datenbank ein Sperrtimeout meldet. Standardmäßig wird unbegrenzt gewartet. Wird dieser Wert angegeben, wird er als Standardwert für alle Anweisungen der Verbindung verwendet. Beachten Sie, dass **Statement.setQueryTimeout()** zum Festlegen des Timeouts für bestimmte Anweisungen verwendet werden kann. Der Wert kann auch 0 sein (keine Wartezeit). |
| loginTimeout<br/><br/>INT<br/>[0..65535]<br/><br/>15 | Die Wartezeit in Sekunden, bevor der Treiber bei einem Verbindungsfehler ein Timeout meldet. Mit dem Wert 0 wird angegeben, dass das Timeout das Standardsystemtimeout ist, das standardmäßig auf 15 Sekunden festgelegt ist. Ein Wert ungleich 0 gibt die Wartezeit in Sekunden an, bevor der Treiber bei einem Verbindungsfehler ein Timeout meldet.<br/><br/> Wenn Sie in der **Server**-Verbindungseigenschaft den Namen eines virtuellen Netzwerks angeben, müssen Sie einen Timeoutwert von mindestens drei Minuten angeben, damit ausreichend Zeit für die Herstellung einer Failoververbindung vorhanden ist. Weitere Informationen finden Sie unter [JDBC-Treiber-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md). |
| msiClientId<br/><br/>String<br/><br/>NULL | Die Client-ID der verwalteten Identität (MSI), die zum Abrufen von **accessToken** verwendet werden soll, wenn eine Verbindung im **ActiveDirectoryMSI**-Authentifizierungsmodus hergestellt wird.|
| multiSubnetFailover<br/><br/>Boolean<br/><br/>false | Geben Sie immer **multiSubnetFailover=true** an, wenn Sie eine Verbindung mit dem Verfügbarkeitsgruppenlistener einer [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]-Verfügbarkeitsgruppe oder einer [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]-Failoverclusterinstanz herstellen. **multiSubnetFailover=true** konfiguriert [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)], um eine schnellere Erkennung sowie die Verbindung zu dem (gerade) aktiven Server zu gewährleisten. Mögliche Werte sind true und false. Weitere Informationen finden Sie unter [JDBC-Treiberunterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md).<br/><br/> Sie können auf die **multiSubnetFailover**-Verbindungseigenschaft mit [getPropertyInfo](../../connect/jdbc/reference/getpropertyinfo-method-sqlserverdriver.md), [getMultiSubnetFailover](../../connect/jdbc/reference/getmultisubnetfailover-method-sqlserverdatasource.md) und [setMultiSubnetFailover](../../connect/jdbc/reference/setmultisubnetfailover-method-sqlserverdatasource.md) programmgesteuert zugreifen.<br/><br/> **Hinweis:**  Ab Version 6.0 des Microsoft-JDBC-Treibers für SQL Server ist es nicht mehr erforderlich, **multiSubnetFailover** auf „true“ festzulegen, wenn eine Verbindung mit einem Verfügbarkeitsgruppenlistener hergestellt wird. Die neue Eigenschaft **transparentNetworkIPResolution**, die standardmäßig aktiviert ist, ermöglicht die Erkennung des (gerade) aktiven Servers und die Herstellung einer Verbindung mit diesem Server. |
| packetSize<br/><br/>INT<br/>[-1 &#124; 0 &#124; 512..32767]<br/><br/>8.000 | Die Netzwerkpaketgröße in Byte, die für die Kommunikation mit SQL Server verwendet wird. Ein Wert von -1 gibt an, dass die Standardpaketgröße des Servers verwendet wird. Ein Wert von 0 gibt an, dass der Maximalwert verwendet wird, d. h. 32767. Wenn diese Eigenschaft auf einen Wert außerhalb des zulässigen Bereichs festgelegt wird, wird eine Ausnahme ausgelöst.<br/><br/> **Wichtig:**  Das Verwenden der packetSize-Eigenschaft bei aktivierter Verschlüsselung (encrypt=true) wird nicht empfohlen. Andernfalls könnte der Treiber einen Verbindungsfehler auslösen. Weitere Informationen finden Sie unter der [setPacketSize](../../connect/jdbc/reference/setpacketsize-method-sqlserverdatasource.md)-Methode der [SQLServerDataSource](../../connect/jdbc/reference/sqlserverdatasource-class.md)-Klasse. |
| password<br/><br/>String<br/>[&lt;=128 char]<br/><br/>NULL | Das Datenbankkennwort im Fall einer Verbindung mit SQL-Benutzer und -Kennwort.<br/>Bei Kerberos-Verbindungen mit Prinzipalname und Kennwort ist diese Eigenschaft auf das Kennwort des Kerberos-Prinzipals festgelegt. |
| portNumber,<br/>port<br/><br/>INT<br/>[0..65535]<br/><br/>1433 | Der Port, der von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] überwacht wird. Wird die Portnummer in der Verbindungszeichenfolge angegeben, erfolgt keine Anforderung an den SQL-Browser. Wenn "port" und "instanceName" angegeben werden, wird die Verbindung zum angegebenen Port hergestellt. **instanceName** wird jedoch überprüft. Wenn „instanceName“ und Port nicht übereinstimmen, wird ein Fehler ausgegeben.<br/><br/> **Wichtig:** Es wird empfohlen, immer die Portnummer anzugeben, da dies sicherer ist als die Verwendung von SQLbrowser. |
| queryTimeout<br/><br/>INT<br/><br/>-1 | Die Anzahl von Sekunden, die gewartet wird, bevor ein Timeout für eine Abfrage auftritt ist. Der Standardwert lautet „-1“, d. h. ein unendliches Timeout. Eine Festlegung auf „0“ impliziert auch eine unbegrenzte Wartezeit. |
| responseBuffering<br/><br/>String<br/>["full" &#124; "adaptive"]<br/><br/>adaptive | Wenn diese Eigenschaft auf "adaptive" festgelegt ist, werden nach Bedarf so wenig Daten wie möglich gepuffert. Der Standardmodus lautet „adaptiv“.<br/><br/> Wenn diese Eigenschaft auf "full" festgelegt ist, wird das gesamte Resultset vom Server gelesen, wenn eine Anweisung ausgeführt wird.<br/><br/> **Hinweis:** Nach dem Upgrade des JDBC-Treibers von Version 1.2 lautet das standardmäßige Pufferverhalten „adaptiv“. Wenn die responseBuffering-Eigenschaft in der Anwendung nie festgelegt wurde und Sie das Standardverhalten aus Version 1.2 in der Anwendung beibehalten möchten, müssen Sie die responseBufferring-Eigenschaft entweder in den Verbindungseigenschaften oder mit der [setResponseBuffering](../../connect/jdbc/reference/setresponsebuffering-method-sqlserverstatement.md)-Methode des [SQLServerStatement](../../connect/jdbc/reference/sqlserverstatement-class.md)-Objekts auf "full" festlegen. |
| selectMethod<br/><br/>String<br/>["direct" &#124; "cursor"]<br/><br/>direct | Wenn diese Eigenschaft auf "cursor" festgelegt wird, wird bei **TYPE_FORWARD_ONLY**- und **CONCUR_READ_ONLY**-Cursorn für jede Abfrage, die für die Verbindung erstellt wird, ein Datenbankcursor erstellt. Diese Eigenschaft ist normalerweise nur dann erforderlich, wenn die Anwendung umfangreiche Resultsets generiert, die nicht vollständig in den Clientspeicher übernommen werden können. Wird diese Eigenschaft "cursor" eingestellt, wird nur eine begrenzte Anzahl von Resultsetzeilen in den Clientspeicher übernommen. <br/><br/>Standardmäßig werden alle Resultsetzeilen in den Clientspeicher übernommen. Dieses Verhalten weist die höchste Leistung auf, wenn die Anwendung alle Zeilen verarbeitet. |
| sendStringParameters...<br/>AsUnicode<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | *sendStringParametersAsUnicode*<br/><br/>Wenn die **sendStringParametersAsUnicode**-Eigenschaft auf „TRUE“ festgelegt ist, werden String-Parameter im Unicode-Format an den Server gesendet.<br/><br/> Wenn die **sendStringParametersAsUnicode**-Eigenschaft auf „FALSE“ festgelegt ist, werden String-Parameter nicht im Unicode-Format, sondern in einem anderen Format wie ASCII/MBCS an den Server gesendet.<br/><br/> Der Standardwert für die **sendStringParametersAsUnicode**-Eigenschaft lautet „TRUE“.<br/><br/> **Hinweis:** Die **sendStringParametersAsUnicode**-Eigenschaft ist nur aktiviert, wenn ein Parameterwert mit den JDBC-Typen **CHAR**, **VARCHAR** oder **LONGVARCHAR** gesendet wird. Di neuen JDBC 4.0-Methoden für nationale Zeichensätze wie setNString, setNCharacterStream und setNClob der [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md)- und [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md)-Klasse senden ihre Parameterwerte unabhängig vom Wert dieser Eigenschaft immer im Unicode-Format an den Server.<br/><br/> Zur Erzielung einer optimalen Leistung mit den JDBC-Datentypen **CHAR**, **VARCHAR** und **LONGVARCHAR** sollte in einer Anwendung die **sendStringParametersAsUnicode**-Eigenschaft auf „FALSE“ festgelegt werden, und die Methoden für nicht nationale Zeichensätze setString, setCharacterStream und setClob der [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md)- und [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md)-Klasse sollten verwendet werden.<br/><br/> Wenn die **sendStringParametersAsUnicode**-Eigenschaft in der Anwendung auf „FALSE“ festgelegt und eine Methode für nicht nationale Zeichensätze für den Zugriff auf Unicode-Datentypen auf Serverseite verwendet wird (z.B. **nchar**, **nvarchar** und **ntext**), gehen möglicherweise Daten verloren, wenn die Datenbanksortierung die von der Methode für nicht nationale Zeichensätze im String-Parameter übergebenen Zeichen nicht unterstützt.<br/><br/> Beachten Sie, dass eine Anwendung die setNString-, setNCharacterStream- und setNClob-Methoden für nationale Zeichensätze der Klassen [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) und [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) für die JDBC-Datentypen **NCHAR**, **NVARCHAR** und **LONGNVARCHAR** verwenden sollte. |
| sendTemporalDataTypesAsStringForBulkCopy<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | Wenn diese Verbindungseigenschaft auf „false“ festgelegt ist, werden die Datentypen **DATE**, **DATETIME**, **DATIMETIME2**, **DATETIMEOFFSET**, **SMALLDATETIME** und **TIME** in Form ihrer jeweiligen Datentypen und nicht als Zeichenfolgen gesendet.<br/><br/>Hinweis: Wenn diese Verbindungseigenschaft auf „false“ festgelegt ist, akzeptiert der Treiber für jeden temporalen Datentyp nur das Standardformat des Zeichenfolgenliterals. Beispiel:<br/><br/>DATE: JJJJ-MM-TT<br/>DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]<br/>DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]<br/>DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+/-}hh:mm]<br/>SMALLDATETIME:YYYY-MM-DD hh:mm:ss<br/>TIME: hh:mm:ss[.nnnnnnn]<br/> |
| sendTimeAsDatetime<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | Diese Eigenschaft wurde in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] JDBC Driver 3.0 hinzugefügt.<br/><br/> Bei Festlegung auf „true“ werden java.sql.Time-Werte als **datetime**-Typen von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] an den Server zurückgegeben. <br/>Bei Festlegung auf „false“ werden java.sql.Time-Werte als **time**-Typen von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] an den Server zurückgegeben.<br/><br/> Der Standardwert für diese Eigenschaft lautet zurzeit „true“, dies kann sich in künftigen Versionen ändern.<br/><br/> Weitere Informationen darüber, wie [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] java.sql.Time-Werte vor dem Senden an den Server konfiguriert, finden Sie unter [Konfigurieren der Art und Weise, wie java.sql.Time-Werte an den Server gesendet werden](../../connect/jdbc/configuring-how-java-sql-time-values-are-sent-to-the-server.md). |
| serverName,<br/>server<br/><br/>String<br/><br/>NULL | Der Computer, auf dem [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ausgeführt wird.<br/><br/> Sie können auch den Namen des virtuellen Netzwerks für eine [!INCLUDE[ssHADR](../../includes/sshadr_md.md)]-Verfügbarkeitsgruppe angeben. Weitere Informationen finden Sie unter [JDBC-Treiber-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md). |
| serverNameAsACE<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | Legen Sie, beginnend mit dem Microsoft JDBC-Treiber 6.0 für SQL Server, die Eigenschaft auf „true“ fest, um anzugeben, dass der Treiber für die Verbindung den Unicodeservernamen in eine ASCII-kompatible Codierung übersetzen soll (Punycode). Wenn diese Einstellung auf „false“ festgelegt ist, stellt der Treiber die Verbindung unter Verwendung des vom Benutzer bereitgestellten Servernamens her.<br/><br/> Weitere Informationen finden Sie unter [Internationale Funktionen des JDBC-Treibers](../../connect/jdbc/international-features-of-the-jdbc-driver.md). |
| serverPreparedStatement...<br/>DiscardThreshold<br/><br/>Integer<br/><br/>10 | *serverPreparedStatementDiscardThreshold*<br/><br/>Ab Version 6.2 des JDBC-Treibers für SQL Server kann mit dieser Eigenschaft gesteuert werden, wie viele ausstehende Aktionen zum Verwerfen von vorbereiteten Anweisungen (<code>sp_unprepare</code>) pro Verbindung vorhanden sein dürfen, bevor ein Aufruf zum Bereinigen der ausstehenden Handles auf dem Server ausgeführt wird. <br/><br/> Wenn diese Eigenschaft auf „&lt;= 1“ festgelegt ist, werden Aktionen zum Aufheben der Vorbereitung sofort nach Abschluss der vorbereiteten Anweisung ausgeführt. Wenn die Eigenschaft auf „&gt;1“ festgelegt ist, werden diese Aufrufe in einem Batch zusammengefasst, um den Overhead eines zu häufigen Aufrufs von „sp_unprepare“ zu vermeiden. |
| serverSpn<br/><br/>String<br/><br/>NULL | Ab dem Microsoft JDBC-Treiber 4.2 für SQL Server kann diese optionale Eigenschaft verwendet werden, um den Dienstprinzipalnamen (Service Principal Name, SPN) für eine Java-Kerberos-Verbindung anzugeben.  Sie wird in Verbindung mit **authenticationScheme** verwendet.<br/><br/> Der SPN kann in der Form „MSSQLSvc/fqdn:port@REALM“ angegeben werden, wobei „fqdn“ den vollqualifizierten Domänennamen, „port“ die Portnummer und „REALM“ den Kerberos-Bereich des SQL Server-Computers in Großbuchstaben darstellen.<br/><br/> Hinweis: Die Angabe „@REALM“ ist optional, wenn der Standardbereich des Clients (gemäß Angabe in der Kerberos-Konfiguration) mit dem Kerberos-Bereich des SQL Server-Computers übereinstimmt.<br/><br/> Weitere Informationen zum Verwenden von **serverSpn** mit Java Kerberos finden Sie unter [Herstellen von Verbindungen mit SQL Server mit der integrierten Kerberos-Authentifizierung](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). |
| socketFactoryClass<br/><br/>String<br/><br/>NULL | Gibt den Klassennamen für eine benutzerdefinierte Socketfactory an, die anstelle der Standardsocketfactory verwendet werden soll. |
| socketTimeout<br/><br/>INT<br/><br/>0 | Die Anzahl von Millisekunden, die gewartet wird, bevor ein Timeout für einen Vorgang zum Lesen oder Akzeptieren eines Sockets auftritt. Der Standardwert lautet „0“, d. h. ein unendliches Timeout. |
| statementPooling...<br/>CacheSize<br/><br/>INT<br/><br/>0 | *statementPoolingCacheSize*<br/><br/>Ab Version 6.4 des JDBC-Treibers für SQL Server kann diese Eigenschaft verwendet werden, um das Zwischenspeichern von Handles für vorbereitete Anweisungen im Treiber zu ermöglichen. <br/><br/>Diese Eigenschaft definiert die Größe des Caches für das Anweisungspooling. <br/><br/>Diese Eigenschaft kann nur in Verbindung mit der Verbindungseigenschaft **disableStatementPooling** verwendet werden, die auf „false“ festgelegt werden sollte. Das Festlegen von **disableStatementPooling** auf „true“ oder das Festlegen von **statementPoolingCacheSize** auf 0 deaktiviert das Zwischenspeichern von Handles für vorbereitete Anweisungen.|
| sslProtocol<br/><br/>String<br/><br/>TLS | Ab Version 6.4 des JDBC-Treibers für SQL Server kann diese Eigenschaft verwendet werden, um das TLS-Protokoll anzugeben, das bei sicheren Verbindungen berücksichtigt werden soll. <br/>Mögliche Werte: **TLS**, **TLSv1**, **TLSv1.1** und **TLSv1.2**. <br/><br/>Weitere Informationen finden Sie unter [SSLProtocol](https://github.com/Microsoft/mssql-jdbc/wiki/SSLProtocol). |
| transparentNetwork...<br/>IPResolution<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | *transparentNetworkIPResolution*<br/><br/>Ab Version 6.0 des Microsoft-JDBC-Treibers für SQL Server bietet diese Eigenschaft eine schnellere Erkennung des (gerade) aktiven Servers und die Herstellung einer Verbindung mit diesem Server. Mögliche Werte sind „true“ und „false“, wobei „true“ der Standardwert ist.<br/><br/> Vor Version 6.0 des Microsoft-JDBC-Treibers für SQL Server musste eine Anwendung „multiSubnetFailover=true“ in die Verbindungszeichenfolge einschließen, um anzugeben, dass eine Verbindung mit einer Always On-Verfügbarkeitsgruppe hergestellt wurde. Wenn das Verbindungsschlüsselwort **multiSubnetFailover** nicht auf „true“ festgelegt wird, kann bei der Verbindung mit einer Always On-Verfügbarkeitsgruppe ein Timeout in der Anwendung auftreten. Ab Version 6.0 des Microsoft-JDBC-Treibers für SQL Server muss eine Anwendung „multiSubnetFailover“ nicht mehr auf „true“ festlegen. <br/><br/>**Hinweis:** Bei „transparentNetworkIPResolution=true“ verwendet der erste Verbindungsversuch 500 ms als Timeout. Alle nachfolgenden Versuche verwenden dieselbe Timeoutlogik wie die multiSubnetFailover-Eigenschaft. |
| trustManagerClass<br/><br/>String<br/><br/>NULL | Der vollqualifizierte Klassenname einer benutzerdefinierten <code>javax.net.ssl.TrustManager</code>-Implementierung. |
| trustManager...<br/>ConstructorArg<br/><br/>String<br/><br/>NULL | *trustManagerConstructorArg*<br/><br/>Ein optionales Argument, das an den Konstruktor des Trust-Managers übergeben wird. Wenn „trustManagerClass“ angegeben ist und eine verschlüsselte Verbindung angefordert wird, wird nicht der standardmäßige, auf dem JVM-Keystore basierende Trust-Manager des Systems verwendet, sondern der benutzerdefinierte Trust-Manager. |
| trustServerCertificate<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | Bei Festlegung auf „TRUE“ überprüft [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] das TLS-/SSL-Zertifikat von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] nicht.<br/><br/> Bei „TRUE“ wird dem TLS-/SSL-Zertifikat von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] automatisch vertraut, wenn die Kommunikationsebene über TLS verschlüsselt ist.<br/><br/> Bei „FALSE“ überprüft [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] das TLS-/SSL-Serverzertifikat. Wenn bei der Überprüfung des Serverzertifikats ein Fehler auftritt, löst der Treiber einen Fehler aus und trennt die Verbindung. Der Standardwert ist FALSE. Vergewissern Sie sich, dass der an **serverName** übergebene Wert für eine erfolgreiche TLS-/SSL-Verbindung exakt dem allgemeinen Namen (CN, Common Name) oder dem DNS-Namen im alternativen Antragstellernamen (SAN, Subject Alternate Name) im Serverzertifikat entspricht. Weitere Informationen finden Sie unter [Verstehen der Verschlüsselungsunterstützung](../../connect/jdbc/understanding-ssl-support.md).<br/><br/> **Hinweis:** Diese Eigenschaft wird in Kombination mit den Eigenschaften **encrypt**/**authentication** verwendet. Diese Eigenschaft hat nur dann Auswirkungen auf die Überprüfung des TLS-/SSL-Serverzertifikats, wenn die Verbindung die TLS-Verschlüsselung verwendet. |
| trustStore<br/><br/>String<br/><br/>NULL | Der Pfad (einschließlich Dateiname) zur trustStore-Zertifikatsdatei. Die trustStore-Datei enthält die Liste der Zertifikate, denen der Client vertraut.<br/><br/> Wenn diese Eigenschaft nicht angegeben oder auf NULL festgelegt ist, verwendet der Treiber die Suchregeln der Trust-Manager-Factory, um den zu verwendenden Zertifikatspeicher zu ermitteln.<br/><br/> **Die Standard-SunX509 TrustManagerFactory versucht, die vertrauenswürdigen Informationen in der folgenden Suchreihenfolge zu suchen:**<br/><br/> Eine von der Java Virtual Machine (JVM)-Systemeigenschaft "javax.net.ssl.trustStore" angegebene Datei<br/><br/> Datei „&lt;java-home&gt;/lib/security/jssecacerts“.<br/><br/> Datei „&lt;java-home&gt;/lib/security/cacerts“.<br/><br/> <br/><br/> Weitere Informationen finden Sie in der Dokumentation zur SunX509 TrustManager-Schnittstelle auf der Website von Sun Microsystems.<br/><br/> **Hinweis:** Diese Eigenschaft hat nur dann Auswirkungen auf die trustStore-Zertifikatsuche, wenn die Verbindung die TLS-Verschlüsselung verwendet und die Eigenschaft **trustServerCertificate** auf „FALSE“ festgelegt ist. |
| trustStorePassword<br/><br/>String<br/><br/>NULL | Das Kennwort, das zum Überprüfen der Integrität der trustStore-Daten verwendet wird.<br/><br/> Wenn die trustStore-Eigenschaft festgelegt ist, die trustStorePassword-Eigenschaft jedoch nicht festgelegt wurde, wird die Integrität von "trustStore" nicht überprüft.<br/><br/> Wenn die trustStore-Eigenschaft und die trustStorePassword-Eigenschaft nicht angegeben wurden, verwendet der Treiber die JVM-Systemeigenschaften „javax.net.ssl.trustStore“ und „javax.net.ssl.trustStorePassword“. Wenn die Systemeigenschaft "javax.net.ssl.trustStorePassword" nicht angegeben wird, wird die Integrität von trustStore nicht überprüft.<br/><br/> Wenn die trustStore-Eigenschaft nicht festgelegt ist, die trustStorePassword-Eigenschaft jedoch festgelegt ist, verwendet der JDBC-Treiber die von „javax.net.ssl.trustStore“ angegebene Datei als Vertrauensspeicher, und die Integrität des Vertrauensspeichers wird mithilfe des angegebenen „trustStorePassword“ überprüft. Dies kann erforderlich sein, wenn in der Clientanwendung das Kennwort nicht in der JVM-Systemeigenschaft gespeichert werden soll.<br/><br/> **Hinweis:**  Die trustStorePassword-Eigenschaft hat nur dann Auswirkungen auf die trustStore-Zertifikatsuche, wenn die Verbindung die TLS-Verschlüsselung verwendet und die Eigenschaft **trustServerCertificate** auf „FALSE“ festgelegt ist. |
| trustStoreType<br/><br/>String<br/><br/>JKS | Legen Sie diese Eigenschaft fest, um den Vertrauensspeichertyp anzugeben, der für den FIPS-Modus verwendet werden soll. <br/><br/>Mögliche Werte sind **PKCS12** oder ein vom FIPS-Anbieter definierter Typ. |
| useBulkCopyFor...<br/>BatchInsert<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | _useBulkCopyForBatchInsert_<br/><br/> Ab Version 7.0 des Microsoft-JDBC-Treibers für SQL Server kann diese Verbindungseigenschaft aktiviert werden, um die Massenkopieren-API zu verwenden, wenn zur Leistungsverbesserung Batcheinfügevorgänge mithilfe von `java.sql.PreparedStatement` ausgeführt werden. <br/><br/>Dieses Feature ist nur funktionsfähig, wenn der Zielserver den Typ **Azure Data Warehouse** aufweist. Das Feature ist standardmäßig deaktiviert; legen Sie diese Eigenschaft auf „true“ fest, um sie zu aktivieren. <br/></br> **Wichtiger Hinweis:** Dieses Feature unterstützt nur vollständig parametrisierte INSERT-Abfragen. Wenn INSERT-Abfragen mit anderen SQL-Abfragen kombiniert werden oder Daten in Werten enthalten, erfolgt die Ausführung wieder mit den einfachen Batcheinfügevorgängen. <br/><br/> Weitere Informationen zu Verwendung dieser Eigenschaft finden Sie unter [Verwenden der Massenkopieren-API für den Batcheinfügevorgang](use-bulk-copy-api-batch-insert-operation.md).|
| useFmtOnly<br /><br />boolean<br />["true" &#124; "false"]<br /><br />false | Ab Version 7.4 bietet der Microsoft-JDBC-Treiber für SQL Server eine alternative Möglichkeit zum Abfragen von Parametermetadaten des Servers, indem die Verbindungseigenschaft **useFmtOnly** angegeben wird. Legen Sie diese Eigenschaft auf „true“ fest, um anzugeben, dass der Treiber beim Abfragen von Parametermetadaten die `SET FMTONLY`-Logik verwenden soll. Dieses Feature ist standardmäßig deaktiviert, und die Verwendung dieser Eigenschaft wird nicht empfohlen, da `SET FMTONLY` als veraltet markiert ist. **useFmtOnly** wird nur als Problemumgehung für bekannte Probleme und Einschränkungen in [`sp_describe_undeclared_parameters`](../../relational-databases/system-stored-procedures/sp-describe-undeclared-parameters-transact-sql.md) zur Verfügung gestellt.<br/><br/> Dieses Feature unterstützt derzeit nur einzelne `SELECT/INSERT/UPDATE/DELETE`-Abfragen. Wenn Sie dieses Feature mit nicht unterstützten oder mehreren Abfragen verwenden, versucht der Treiber, diese Abfragen zu analysieren, dies führt aber höchstwahrscheinlich zu einer Ausnahme.<br/><br/> Weitere Informationen finden Sie unter [Abrufen von ParameterMetaData über useFmtOnly](../../connect/jdbc/using-usefmtonly.md). |
| userName,<br/>user<br/><br/>String<br/>[&lt;=128 char]<br/><br/>NULL | Der Datenbankbenutzer im Fall einer Verbindung mit SQL-Benutzer und -Kennwort.<br/><br/>Bei Kerberos-Verbindungen mit Prinzipalname und Kennwort ist diese Eigenschaft auf den Namen des Kerberos-Prinzipals festgelegt. |
| workstationID<br/><br/>String<br/>[&lt;=128 char]<br/><br/>&lt;leere Zeichenfolge&gt; | Die ID der Arbeitsstation. Anhand dieser Eigenschaft wird die jeweilige Arbeitsstation in den verschiedenen [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Profilerstellungs- und Protokollierungstools identifiziert. <br/><br/>Wenn keine Angabe erfolgt, wird die &lt;leere Zeichenfolge&gt; verwendet. |
| xopenStates<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | Legen Sie diese Eigenschaft auf "true" fest, um anzugeben, dass der Treiber in Ausnahmen XOPEN-kompatible Statuscodes zurückgibt. <br/><br/>Standardmäßig werden SQL 99-Statuscodes zurückgegeben. |
| &nbsp; | &nbsp; |

> [!NOTE]  
> [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] akzeptiert die standardmäßigen Serverwerte für Verbindungseigenschaften, außer „ANSI_DEFAULTS“ und „IMPLICIT_TRANSACTIONS“. [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] legt „ANSI_DEFAULTS“ automatisch auf „ON“ und „IMPLICIT_TRANSACTIONS“ automatisch auf „OFF“ fest.

> [!Important]
> Wenn die Authentifizierung auf „ActiveDirectoryPassword“ festgelegt ist, muss die folgende Bibliothek in den Klassenpfad eingeschlossen werden: [azure-activedirectory-library-for-java](https://github.com/AzureAD/azure-activedirectory-library-for-java). Sie finden diese im [Maven-Repository](https://mvnrepository.com/artifact/com.microsoft.azure/adal4j). Die einfachste Möglichkeit, die Bibliothek und die zugehörigen Abhängigkeiten herunterzuladen, ist die Verwendung von Maven:
> 1. Installieren Sie zuerst Maven auf Ihrem System.
> 2. Wechseln Sie zur [GitHub-Seite](https://github.com/Microsoft/mssql-jdbc) des Treibers.
> 3. Laden Sie die Datei „pom.xml“ herunter.
> 4. Führen Sie den folgenden Maven-Befehl aus, um die Bibliothek und ihre Abhängigkeiten herunterzuladen: `mvn dependency:copy-dependencies`.

## <a name="see-also"></a>Weitere Informationen

[Verbinden mit SQL Server mit dem JDBC-Treiber](../../connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver.md)  
[FIPS-Modus](../../connect/jdbc/fips-mode.md)